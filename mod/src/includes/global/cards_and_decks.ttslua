local MARVEL_CDB_PUBLIC_DECK_URL = "https://marvelcdb.com/api/public/decklist/"
local MARVEL_CDB_PRIVATE_DECK_URL = "https://marvelcdb.com/api/public/deck/"

function isCard(x)
    return x.tag == 'Card'
end

function isDeck(x)
    return x.tag == 'Deck'
end

function isCardOrDeck(x)
    return isCard(x) or isDeck(x)
end

function dealEncounterCardsToAllPlayers(params)
    local numberOfCards = params.numberOfCards
    local cardsPerPlayer = params.cardsPerPlayer or 1
    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local allPlayers = heroManager.call("getPlayersInPlayerOrder")

    if(numberOfCards == nil) then
        numberOfCards = cardsPerPlayer * #allPlayers
    end

    function dealCardsCoroutine()
        local playerIndex = 1

        for i = 1, numberOfCards do
            local color = allPlayers[playerIndex].playerColor

            dealEncounterCardToPlayer({
                playerColor = color
            })

            playerIndex = playerIndex + 1

            if(playerIndex > #allPlayers) then
                playerIndex = 1
            end

            local i = 1

            while (Global.getVar("shuffling-encounter") or i < 30) do
                coroutine.yield(0)
                i = i + 1
            end
        end

        return 1
    end

    startLuaCoroutine(self, "dealCardsCoroutine")
end

function dealEncounterCardToPlayer(params)
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    if (not scenarioManager.call("isScenarioInProgress")) then
        return
    end

    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local playerColor = params.playerColor
    local playmat = heroManager.call("getPlaymat", {
        playerColor = playerColor
    })
    local faceUp = params.faceUp ~= nil and params.faceUp or false
    local dealToPosition = Vector(playmat.call("getEncounterCardPosition"))
    local dealToRotation = faceUp and {0, 180, 0} or {0, 180, 180}
    local encounterDeckPosition = Vector(scenarioManager.call('getEncounterDeckPosition'))

    local deckOrCard = getDeckOrCardAtPosition({position = encounterDeckPosition})

    --If there is no encounter deck, refresh the deck and try again
    if not deckOrCard then
        refreshEncounterDeck()

        Wait.frames(function()
            dealEncounterCardToPlayer(params)
        end, 
        30)

        return
    end

    local card
    local refreshNeeded = false

    if deckOrCard.tag == 'Deck' then
        card = deckOrCard.takeObject()
    else
        card = deckOrCard
        refreshNeeded = true
    end

    moveCard({
        card = card,
        destinationPosition = dealToPosition,
        destinationRotation = dealToRotation
    })

    if(refreshNeeded) then
        Wait.frames(function()
            refreshEncounterDeck()
        end, 10)
    end
end

function drawBoostcard()
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    local encounterDeckPosition = Vector(scenarioManager.call('getEncounterDeckPosition'))
    local drawToPosition = Vector(scenarioManager.call('getBoostDrawPosition'))
    local drawToRotation = {0, 180, 180}
    
    local deckOrCard = getDeckOrCardAtPosition({position = encounterDeckPosition})

    --If there is no encounter deck, refresh the deck and try again
    if not deckOrCard then
        refreshEncounterDeck()

        Wait.frames(function()
            drawBoostcard()
        end, 
        30)

        return
    end
    
    local card
    local refreshNeeded = false

    if (deckOrCard.tag == 'Deck') then
        card = deckOrCard.takeObject()
    else
        card = deckOrCard
        refreshNeeded = true
    end
    
    moveCard({
        card = card,
        destinationPosition = drawToPosition,
        destinationRotation = drawToRotation
    })

    if(refreshNeeded) then
        Wait.frames(function()
            refreshEncounterDeck()
        end, 10)
    end
end

function discardEncounterCard(params)
    local card = params.card or nil
    local discardFromPosition = params.discardFromPosition
    local stagingPosition = ensureMinimumYPosition({position = discardFromPosition, minimumY = 2.0})
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    local encounterDiscardPosition = ensureMinimumYPosition({position = Vector(scenarioManager.call('getEncounterDiscardPosition')), minimumY = 2.0})

    if(not card) then
        local deckOrCard = getDeckOrCardAtPosition({
            position = discardFromPosition
        })

        if(not deckOrCard) then return end
    
        if(deckOrCard.tag == "Deck") then
            card = deckOrCard.takeObject()
        else
            card = deckOrCard
        end
    end

    moveCard({
        card = card,
        destinationPosition = encounterDiscardPosition,
        destinationRotation = {0, 180, 0},
        moveFast = true,
        faceUpOnRaise = true
    })
end

function discardBoostcard()
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    local boostPosition = Vector(scenarioManager.call('getBoostDrawPosition'))

    discardEncounterCard({
        discardFromPosition = boostPosition
    })
end

function discardPlayerEncounterCard(params)
    local playerColor = params.playerColor
    local encounterPosition = Global.getTable("ENCOUNTER_" .. playerColor:upper() .. "_POS")

    discardEncounterCard({
        discardFromPosition = encounterPosition
    })
end

function refreshEncounterDeck()
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    local encounterDeckPosition = Vector(scenarioManager.call('getEncounterDeckPosition')) + Vector(0,1.5,0)
    local encounterDiscardPosition = Vector(scenarioManager.call('getEncounterDiscardPosition'))

    refreshDeck({deckPosition = encounterDeckPosition, discardPosition = encounterDiscardPosition, deckType = "encounter"})

    displayMessage({
        message = "Reshuffled the encounter deck.",
        messageType = MESSAGE_TYPE_INFO
    })

    incrementAccelerationCounter()
end

function nameDeck(params)
    local deckPosition = Vector(params.deckPosition)
    local name = params.name

    local deck = getDeckAtPosition({
        position = deckPosition
    })

    if (deck) then
        deck.setName(name)
    end
end

function shuffleDeck(params)
    local deckPosition = Vector(params.deckPosition)
    local deck = getDeckAtPosition({
        position = deckPosition
    })

    if(deck) then
        deck.shuffle()
    else
        log("deck not found at position {" .. deckPosition.x .. "," .. deckPosition.y .. "," .. deckPosition.z .. "}")
    end
end

function isFaceUp(params)
    local object = params.object
    local z = object.getRotation()["z"]

    return z > 355 or z < 5 or not object.hide_when_face_down
end

function isFaceDown(params)
    local object = params.object
    if(not object.hide_when_face_down) then return false end

    local z = object.getRotation()["z"]

    return z >= 170 and z <= 190 and object.hide_when_face_down
end

function deleteCardAtPosition(params)
    local card = getCardAtPosition({position = params.position})

    if(card) then
        removeCountersFromCard({card = card})
        card.destroy()
    end
end

function moveDeck(params)
    local originPosition = params.origin
    local destinationPosition = params.destinationPosition
    local destinationRotation = params.destinationRotation

    local deckOrCard = getDeckOrCardAtPosition({position = originPosition})
    if (not deckOrCard) then return end

    deckOrCard.setPositionSmooth(destinationPosition, false, false)

    if (destinationRotation) then
        deckOrCard.setRotationSmooth(destinationRotation, false, false)
    end
end

function getCardId(params)
    return getCardProperty({
        card = params.card,
        property = "code"
    })
end

function getCardData(params)
    local card = params.card
    local cardData = ""

    if (type(card) == "table") then
        cardData = card.gm_notes or ""
    else
        cardData = card.getGMNotes() or ""
    end

    if (cardData == "") then
        return {}
    end

    return json.decode(cardData)
end

function getCardProperty(params)
    local card = params.card
    local property = params.property

    local cardData = getCardData({
        card = card
    })

    return cardData[property]
end

function setCardProperty(params)
    local card = params.card
    local cardData = getCardData({
        card = card
    })
    cardData[params.property] = params.value
    card.setGMNotes(json.encode(cardData))
end

function moveCard(params)
    local card = params.card
    local destination = calculateDestination(params)
    local raiseHeight = params.raiseHeight or 3.0
    local moveFast = params.moveFast or false
    local faceUpOnRaise = params.faceUpOnRaise or false
    
    card.setLock(false)

    local originalPosition = card.getPosition()
    local raisePosition = ensureMinimumYPosition({
        position = originalPosition,
        minimumY = raiseHeight + 1
    })
    local destinationPosition = ensureMinimumYPosition({
        position = destination.position,
        minimumY = raiseHeight
    })

    local originalRotation = card.getRotation()

    if(faceUpOnRaise) then
        card.setRotation({originalRotation.x, originalRotation.y, 0})
    end

    card.setPosition(raisePosition)

    card.setPositionSmooth(destinationPosition, false, moveFast)
    card.setRotationSmooth(destination.rotation, false, moveFast)
end

function moveCardFromDeck(params)
end

function moveCardFromPosition(params)
    local card = getCardAtPosition({position = params.origin})

    if (not card) then
        return nil
    end

    params.card = card

    moveCard(params)

    return card
end

function moveCardFromDeckById(params)
    local cardId = params.cardId
    local deckPosition = params.deckPosition
    local destinationPosition = Vector(params.destinationPosition)
    local destinationRotation = params.destinationRotation and Vector(params.destinationRotation) or Vector({0, 180, 0})
    local destinationScale = params.destinationScale and Vector(params.destinationScale) or nil
    local flipCard = params.flipCard or false
    local settings = params.settings or {}
    local values = params.values or {}
    local tags = params.tags or {}

    if (flipCard) then
        destinationRotation["z"] = 180
    end

    local cardOrDeck = getDeckOrCardAtPosition({position = deckPosition})

    if(not cardOrDeck) then return false end

    local card

    if(cardOrDeck.tag == "Deck") then
        local deck = cardOrDeck
        for i, cardInDeck in ipairs(deck.getObjects()) do
            local id = getCardId({
                card = cardInDeck
            })
            if (id == cardId) then
                card = deck.takeObject({
                    guid = cardInDeck.guid
                })

                break
            end
        end
    end

    if(not card) then
        local id = getCardId({
            card = cardOrDeck
        })

        if (id == cardId) then
            card = cardOrDeck
        end
    end

    if(not card) then return false end

    moveCard({
        card = card,
        destinationPosition = destinationPosition,
        destinationRotation = destinationRotation
    })

    if (destinationScale) then
        card.setScale(destinationScale)
    end

    if (settings.hideWhenFaceDown ~= nil) then
        card.hide_when_face_down = settings.hideWhenFaceDown
    end

    for key, value in pairs(values) do
        setCardValue({
            cardGuid = card.getGUID(),
            property = key,
            value = value
        })
    end

    for key, tag in pairs(tags) do
        card.addTag(tag)
    end

    return true
end

function spawnCardAndMoveFromEncounterDeckById(params)
    local cardId = params.cardId
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    local encounterDeckPosition = Vector(scenarioManager.call('getEncounterDeckPosition'))
    
    local card = spawnCard({
        cardId = cardId,
        position = encounterDeckPosition,
        scale = CARD_SCALE_ENCOUNTER,
        flipped = true,
        tags = {"group-scenario"}
    })

    params.searchInDiscard = true

    Wait.condition(
        function() 
            Wait.frames(function()
                moveCardFromEncounterDeckById(params)
            end,
            60)
        end,
        function()
            return card.isDestroyed() or card.resting
        end,
        10)
end

function moveCardFromEncounterDeckById(params)
    local cardId = params.cardId
    local searchInDiscard = params.searchInDiscard or false
    local flipCard = params.flipCard or false
    local destination = calculateDestination(params)
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)

    local moveCardParams = {
        cardId = cardId,
        destinationPosition = ensureMinimumYPosition({
            position = destination.position,
            minimumY = 4.0
        }),
        destinationRotation = destination.rotation,
        flipCard = flipCard,
        values = params.values,
        tags = params.tags,
        settings = params.settings
    }

    if searchInDiscard then
        moveCardParams.deckPosition = Vector(scenarioManager.call('getEncounterDiscardPosition'))

        if moveCardFromDeckById(moveCardParams) then
            return true
        end
    end

    moveCardParams.deckPosition = Vector(scenarioManager.call('getEncounterDeckPosition'))

    return moveCardFromDeckById(moveCardParams)
end

function placeSetupCardsFromDeck(params)
    local deckPosition = params.deckPosition
    local deck = getDeckAtPosition({position = deckPosition})

    if not deck then
        log("No deck found at position " .. tostring(deckPosition))
        return
    end

    for i, card in ipairs(deck.getObjects()) do
        local cardData = getCardData({card = card})
        if cardData.setup then
            local cardType = cardData.type
            local zoneIndex = nil
            local destinationPosition = nil

            if(cardType == "environment") then
                zoneIndex = "environment"
            elseif(cardType == "side_scheme") then
                zoneIndex = "sideScheme"
            elseif(cardType == "attachment") then
                zoneIndex = "attachment"
            else
                destinationPosition = {0, 1, 0}
            end

            local destination = calculateDestination({
                zoneIndex = zoneIndex,
                destinationPosition = destinationPosition,
                minimumY = 1.0
            })

            moveCardFromDeckById({
                cardId = cardData.code,
                deckPosition = deckPosition,
                destinationPosition = destination.position,
                destinationRotation = destination.rotation
            })
        end
    end
end

function getItemsOnCard(params)
    card = params.card
    local cardPosition = card.getPosition()
    local castSize = getCastSizeForCard({
        card = card
    })

    local objList = Physics.cast({
        origin = cardPosition,
        direction = {0, 1, 0},
        type = 3,
        size = castSize,
        max_distance = 0,
        debug = false
    })

    local items = {}

    for _, obj in ipairs(objList) do
        local object = obj.hit_object
        if(object.hasTag("counter") or object.hasTag("token")) then
            table.insert(items, object)
        end
    end

    return items
end

function getCastSizeForCard(params)
    local card = params.card
    local cardRotation = card.getRotation()
    local cardScale = card.getScale()
    local y = cardRotation.y
    local orientation = (y >= 0 and y <= 5) or (y >= 355 and y <= 360) or (y >= 175 and y <= 185) and "vertical" or
                            "horizontal"
    local longDimension = cardScale.x * 2.61
    local shortDimension = cardScale.x * 2.06

    return orientation == "vertical" and {shortDimension, 2, longDimension} or {longDimension, 2, shortDimension}
end

function getCardAtPosition(params)
    local position = Vector(params.position)
    position["y"] = 0

    local objects = findInRadiusBy(position, 3, isCard, false)

    if(#objects == 0) then
        return nil
    end

    return objects[1]
end

function getDeckAtPosition(params)
    local position = Vector(params.position)
    position["y"] = 0

    local objects = findInRadiusBy(position, 3, isDeck, false)

    if(#objects == 0) then
        return nil
    end

    return objects[1]
end

function getDeckOrCardAtPosition(params)
    local position = Vector(params.position)
    position["y"] = 0

    local objects = findInRadiusBy(position, 3, isCardOrDeck, false)
    local card = nil

    for _, object in pairs(objects) do
        if (object.tag == "Deck") then
            return object
        elseif (object.tag == "Card" and object.resting) then
            card = object
        end
    end

    return card
end

function discardFromEncounterDeck(params)
    local searchFunction = params.searchFunction
    local searchFunctionTarget = params.searchFunctionTarget
    local searchForCards = searchFunction ~= nil
    local cardsToDiscard = params.cardsToDiscard or 0
    local cardsToFind = params.cardsToFind or 0
    local stopWhenCardsFound = params.stopWhenCardsFound
    params.minimumY = 2.5

    local callBackFunction = params.callBackFunction
    local callBackTarget = params.callBackTarget

    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    local deckPosition = Vector(scenarioManager.call("getEncounterDeckPosition"))
    local discardPosition = Vector(scenarioManager.call("getEncounterDiscardPosition"))

    local destination = calculateDestination(params)
    local deckDepleted = false
    local cardsDiscarded = 0
    local cardsFound = 0
    local stopDiscarding = false

    local deck = getDeckOrCardAtPosition({
        position = deckPosition
    })
    local discardPile = getDeckOrCardAtPosition({
        position = discardPosition
    })

    if not deck then
        refreshEncounterDeck()
    end

    Wait.condition(
        function()
            startLuaCoroutine(self, "discardEncounterCoroutine")
        end, 
        function()
            return discardPile == nil or discardPile.isDestroyed() or discardPile.resting
        end, 
        3, 
        function()
            startLuaCoroutine(self, "discardEncounterCoroutine")
        end
    )

    function discardEncounterCoroutine()
        while not stopDiscarding do
            local card = discardCardFromDeck({
                deckPosition = deckPosition,
                discardPosition = discardPosition,
                discardRotation = destination.rotation
            })

            cardsDiscarded = cardsDiscarded + 1

            if not card then
                deckDepleted = true
                break
            end

            if (searchForCards and cardsFound < cardsToFind) then
                local cardIsMatch = searchFunctionTarget.call(searchFunction, {
                    card = card
                })
                if (cardIsMatch) then
                    moveCard({
                        card = card,
                        destinationPosition = destination.position,
                        destinationRotation = destination.rotation,
                        moveFast = true
                    })
                    cardsFound = cardsFound + 1
                end
            end

            stopDiscarding = deckDepleted or (stopWhenCardsFound and cardsFound >= cardsToFind) or
                                 (cardsToDiscard > 0 and cardsDiscarded >= cardsToDiscard)

            if (not stopDiscarding) then
                for i = 1, 40 do
                    coroutine.yield(0)
                end
            end
        end

        if callBackFunction then
            callBackTarget.call(callBackFunction)
        end

        if searchForCards and cardsFound < cardsToFind then
            message = params.notFoundMessage
            messageType = params.notFoundMessageType or MESSAGE_TYPE_INFO
            playerColor = params.playerColor

            if (message) then
                displayMessage({
                    message = message,
                    messageType = messageType,
                    playerColor = playerColor
                })
            end
        end

        Wait.frames(function()
            local deck = getDeckOrCardAtPosition({
                position = deckPosition
            })
            if (not deck) then
                Wait.frames(function()
                    broadcastToAll("refreshing encounter deck.", {1,1,1})
                    refreshEncounterDeck()
                end, 45)
            end
        end, 30)

        return 1
    end
end

function discardCardFromDeck(params)
    local deckPosition = params.deckPosition
    local discardPosition = ensureMinimumYPosition({
        position = params.discardPosition,
        minimumY = 2.5
    })
    local discardRotation = params.discardRotation or {0, 180, 0}
    local deckOrCard = getDeckOrCardAtPosition({
        position = deckPosition
    })

    if not deckOrCard then return nil end

    local card = nil

    if (deckOrCard.tag == "Deck") then
        card = deckOrCard.takeObject()
    else
        card = deckOrCard
    end

    moveCard({
        card = card,
        destinationPosition = discardPosition,
        destinationRotation = discardRotation,
        moveFast = true
    })

    return card
end

function cardIsInPlay(params)
    local card = findCard(params)
    if not card then
        return false
    end
    return isFaceUp({
        object = card
    })
end

function cardIsInZone(params)
    local card = params.card
    if not card then
        return false
    end

    local zoneIndex = params.zoneIndex
    local zoneDef = getZoneDefinition({zoneIndex = zoneIndex})
    local zones = card.getZones()
    
    for _, zone in pairs(zones) do
        if zone.getGUID() == zoneDef.guid then
            return true
        end
    end

    return false
end

function findCard(params)
    local cardId = params.cardId
    local allObjects = getAllObjects()

    for _, object in pairs(allObjects) do
        if object.tag == "Card" then
            local cardData = getCardData({
                card = object
            })
            if (cardData.code == cardId) then
                return object
            end
        end
    end

    return nil
end

function discardPlayerCard(params)
    local card = params.card
    local playerColor = params.playerColor or
        getCardValue({
            cardGuid = card.getGUID(),
            property = "playerColor"
        })

    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local playmat = heroManager.call("getPlaymat", {
        playerColor = playerColor
    })
    if(not playmat) then return end

    local discardPosition = Vector(playmat.call("getPlayerDiscardPosition"))

    moveCard({
        card = card,
        destinationPosition = discardPosition,
        destinationRotation = {0, 180, 0},
        raiseHeight = 2,
        moveFast = true
    })
end

function discardFromPlayerDeck(params)
    local playerColor = params.playerColor
    local numberOfCards = params.numberOfCards
    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local playmat = heroManager.call("getPlaymat", {
        playerColor = playerColor
    })
    local deckPosition = Vector(playmat.call("getPlayerDeckPosition"))
    local discardPosition = Vector(playmat.call("getPlayerDiscardPosition"))

    local destination = calculateDestination({
        destinationPosition = discardPosition,
        destinationRotation = {0, 180, 0},
        minimumY = 2.5
    })

    function discardCoroutine()
        for i = 1, numberOfCards do
            local card = discardCardFromDeck({
                deckPosition = deckPosition,
                discardPosition = destination.position,
                discardRotation = destination.rotation
            })

            if (not card) then
                Wait.frames(function()
                    refreshPlayerDeck({
                        deckPosition = deckPosition,
                        discardPosition = discardPosition,
                        playerColor = playerColor
                    })
                end, 30)

                return 1
            end

            local count = 0
            while count < 40 do
                count = count + 1
                coroutine.yield(0)
            end
        end

        Wait.frames(function()
            local deck = getDeckOrCardAtPosition({
                position = deckPosition
            })
            if (not deck) then
                Wait.frames(function()
                    refreshPlayerDeck({
                        deckPosition = deckPosition,
                        discardPosition = discardPosition,
                        playerColor = playerColor
                    })
                end, 20)
            end
        end, 30)

        return 1
    end

    startLuaCoroutine(self, "discardCoroutine")
end

function refreshPlayerDeck(params)
    local deckPosition = params.deckPosition
    local discardPosition = params.discardPosition
    local playerColor = params.playerColor

    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local hero = heroManager.call("getSelectedHero", {
        positionColor = playerColor
    })
    local heroName = hero.name

    refreshDeck({
        deckPosition = deckPosition,
        discardPosition = discardPosition,
        deckType = playerColor
    })
    displayMessage({
        message = heroName .. " cycled their deck. Time for an encounter card!",
        messageType = MESSAGE_TYPE_INFO,
        playerColor = playerColor
    })
    dealEncounterCardToPlayer({
        playerColor = playerColor
    })
end

function discardFromAllPlayerDecks(params)
    local numberOfCards = params.numberOfCards
    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local selectedHeroes = heroManager.call("getSelectedHeroes")

    for color, _ in pairs(selectedHeroes) do
        discardFromPlayerDeck({
            playerColor = color,
            numberOfCards = numberOfCards
        })
    end
end

function refreshDeck(params)
    local deckPosition = params.deckPosition
    local discardPosition = params.discardPosition
    
    local deck = getDeckOrCardAtPosition({
        position = discardPosition
    })

    if (not deck) then
        return
    end

    local shuffleFlag = "shuffling-" .. params.deckType
    Global.setVar(shuffleFlag, true)

    deck.setPositionSmooth(deckPosition, false, false)
    deck.setRotationSmooth({0, 180, 180}, false, false)

    Wait.condition(function()
        deck.shuffle()

        Wait.frames(function()
            Global.setVar(shuffleFlag, false)
        end, 90)
    end, function()
        return deck.resting
    end, 2)
end

function importDeck(params)
    local deckId = params.deckId
    local callbackFunction = params.callbackFunction
    local callbackTarget = params.callbackTarget

    -- Try private deck URL first
    WebRequest.get(MARVEL_CDB_PRIVATE_DECK_URL .. deckId, function(res)
        local deckInfo = nil

        if res.is_done and not res.is_error then
            if not string.find(res.text, "<!DOCTYPE html>") then
                deckInfo = JSON.decode(res.text)
            end
        end

        -- If private deck succeeded, use it
        if deckInfo ~= nil then
            callbackTarget.call(callbackFunction, {
                deckInfo = deckInfo
            })
            return
        end

        -- Private deck failed, try public deck URL
        WebRequest.get(MARVEL_CDB_PUBLIC_DECK_URL .. deckId, function(res2)
            local deckInfo2 = nil

            if res2.is_done and not res2.is_error then
                if not string.find(res2.text, "<!DOCTYPE html>") then
                    deckInfo2 = JSON.decode(res2.text)
                end
            end

            -- If public deck succeeded, use it
            if deckInfo2 ~= nil then
                callbackTarget.call(callbackFunction, {
                    deckInfo = deckInfo2
                })
                return
            end

            -- Both failed, show error
            broadcastToAll("Deck " .. deckId .. " not found.\nMake sure the \"Share your decks\" checkbox is checked in your MarvelCDB account page!", {1, 0.27, 0})
            callbackTarget.call(callbackFunction, { deckInfo = nil })
        end)
    end)
end

function isCardInDeck(params)
    local deck = params.deck
    local cardId = params.cardId
    local cards = deck.getObjects()

    for i, card in ipairs(cards) do
        local cardData = getCardData({
            card = card
        })

        if (cardData.code == cardId) then
            return true
        end
    end

    return false
end

function getEncounterDeck()
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    local deckPosition = Vector(scenarioManager.call("getEncounterDeckPosition"))
    return getDeckOrCardAtPosition({
        position = deckPosition
    })
end

function countCardIconsInPlay(params)
    local iconType = params.iconType
    local count = 0
    local allObjects = getAllObjects()
    local deckPositions = getDeckPositions()
    local cardList = {}

    for _, object in pairs(allObjects) do
        if object.tag == "Card" then
            local cardData = getCardData({
                card = object
            })

            if(not cardData) then goto continueIconCount end
            if(cardData.type ~= "main_scheme" and not isFaceUp({object = object})) then goto continueIconCount end --Main schemes are "face down" when in play; all others should be face up
            if(not objectIsOnTable({object = object})) then goto continueIconCount end

            for _, deckPosition in pairs(deckPositions) do
                if objectIsAtPosition({
                    object = object,
                    position = deckPosition
                }) then
                    goto continueIconCount
                end
            end

            local iconCount = tonumber(cardData[iconType] or "0")

            if(iconCount > 0) then
                table.insert(cardList, stripCardSuffix({cardName = object.getName()}))
            end

            count = count + iconCount
        end

        ::continueIconCount::
    end

    return count, cardList
end

function getDeckPositions()
    local deckPositions = {}
    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)

    if(not scenarioManager or not heroManager) then
        return deckPositions
    end

    local heroDeckPositions = heroManager.call("getAllPlayerDeckPositions", {includeDiscard = true}) or {}

    table.insert(deckPositions, Vector(scenarioManager.call('getEncounterDeckPosition')))
    table.insert(deckPositions, Vector(scenarioManager.call('getEncounterDiscardPosition')))

    for _, position in pairs(heroDeckPositions) do
        table.insert(deckPositions, Vector(position))
    end

    return deckPositions
end

function dealMinionToAllPlayers(params)
    local minionCardId = params.cardId
    local heroManager = getObjectFromGUID(Global.getVar("GUID_HERO_MANAGER"))
    local players = heroManager.call("getPlayersInPlayerOrder")

    function dealMinionsCoroutine()
        for _, player in ipairs(players) do
            Global.call("moveCardFromEncounterDeckById", {cardId = minionCardId, zoneIndex = "minion-" .. player.playerColor})

            for i = 1, 25 do
                coroutine.yield(0)
            end
        end

        return 1
    end

    startLuaCoroutine(self, "dealMinionsCoroutine")
end

function getPlayerColorFromDeck(params)
    local deck = params.deck
    local heroManager = getObjectFromGUID(GUID_HERO_MANAGER)
    local players = heroManager.call("getPlayersInPlayerOrder")

    for _, player in ipairs(players) do
        local playmat = heroManager.call("getPlaymat", {
            playerColor = player.playerColor
        })
        local playerDeckPosition = Vector(playmat.call("getPlayerDeckPosition"))

        if objectIsAtPosition({
            object = deck,
            position = playerDeckPosition
        }) then
            return player.playerColor
        end
    end

    return nil
end

function discardCardOrDeck(params)
    local cardOrDeck = params.object
    if(not cardOrDeck) then return end

    local objectType = cardOrDeck.tag

    if(objectType == "Deck") then
        --If the object is a player deck, discard from that deck (refresh if needed))
        local playerDeckColor = getPlayerColorFromDeck({deck = cardOrDeck})

        if playerDeckColor then
            discardFromPlayerDeck({
                playerColor = playerDeckColor,
                numberOfCards = 1
            })
            return
        end

        --If the object is the encounter deck, discard from that deck (refresh if needed))
        local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
        local encounterDeckPosition = scenarioManager.call("getEncounterDeckPosition")

        if objectIsAtPosition({
            object = cardOrDeck,
            position = Vector(encounterDeckPosition)
        }) then
            discardFromEncounterDeck({
                cardsToDiscard = 1
            })
            return
        end

        --Check the top card of the deck to determine where to discard
        local card = cardOrDeck.takeObject()
        local cardData = getCardData({card = card})
        if(not cardData) then return end

        if(cardData.aspect == "encounter") then
            discardEncounterCard({
                card = card
            })
        else
            local cardPlayerColor = getCardPlayerColor({card = card})
            if(cardPlayerColor) then
                discardPlayerCard({
                    card = card,
                    playerColor = cardPlayerColor
                })
                return
            else
                broadcastToAll("Could not determine which discard pile to discard to.", {1,0,0})
            end
        end
    end

    if(objectType ~= "Card") then return end

    local cardData = getCardData({card = cardOrDeck})

    if(cardData.type == "hero") then return end

    --Don't discard locked cards
    if cardOrDeck.getLock() then return end

    --If the card is in a player zone, discard to that player's discard pile
    local zones = cardOrDeck.getZones()

    for _, zone in pairs(zones) do
        if(zone.tag == "Hand") then
            local playerColor = zone.getValue()

            cardOrDeck.use_hands = false

            discardPlayerCard({
                card = cardOrDeck,
                playerColor = playerColor
            })

            Wait.frames(function()
                if(not cardOrDeck.isDestroyed()) then
                    cardOrDeck.use_hands = true
                end
            end, 20)

            return
        end

        local zoneDef = getZoneDefinition({zoneGuid = zone.getGUID()})

        if(zoneDef and (zoneDef.zoneType == "heroExit")) then
            removeCountersFromCard({card = cardOrDeck})
            discardPlayerCard({
                card = cardOrDeck,
                playerColor = zoneDef.playerColor
            })
            return
        end
    end

    --If the card is an encounter card, discard to the encounter discard pile
    if(cardData.aspect == "encounter") then
        removeCountersFromCard({card = cardOrDeck})
        discardEncounterCard({
            discardFromPosition = cardOrDeck.getPosition()
        })
        return
    end

    --If the card has a playerColor tag, discard to that player's discard pile
    local cardPlayerColor = getCardPlayerColor({card = cardOrDeck})
    if(cardPlayerColor) then
        discardPlayerCard({
            card = cardOrDeck,
            playerColor = cardPlayerColor
        })
        return
    end

    --If the player is seated, discard to their discard pile
    local playerColor = params.playerColor
    if(playerColor == "Red" or playerColor == "Blue" or playerColor == "Green" or playerColor == "Yellow") then
        removeCountersFromCard({card = cardOrDeck})
        discardPlayerCard({
            card = cardOrDeck,
            playerColor = playerColor
        })    
        return
    end    

    --Otherwise, notify that a discard deck could not be identified
    broadcastToAll("Could not determine which discard pile to discard to.", {1,0,0})
end

function getCardPlayerColor(params)
    local card = params.card
    local tags = card.getTags()

    for _, tag in pairs(tags) do
        if string.sub(tag, 1, 5) == "group" then
            return string.sub(tag, 7)
        end
    end

    return nil
end

--Zone Manager pass-throughs

function setCardValue(params)
    local layoutManager = getObjectFromGUID(GUID_LAYOUT_MANAGER)
    if(not layoutManager) then return nil end
    layoutManager.call("setCardValue", params)
end

function getCardValue(params)
    local layoutManager = getObjectFromGUID(GUID_LAYOUT_MANAGER)
    if(not layoutManager) then return nil end
    return layoutManager.call("getCardValue", params)
end

function getAllCardValues(params)
    local layoutManager = getObjectFromGUID(GUID_LAYOUT_MANAGER)
    if(not layoutManager) then return nil end
    return layoutManager.call("getAllCardValues", params)
end

function deleteCardFromRegistry(params)
    local layoutManager = getObjectFromGUID(GUID_LAYOUT_MANAGER)
    if(not layoutManager) then return nil end
    layoutManager.call("deleteCardFromRegistry", params)
end