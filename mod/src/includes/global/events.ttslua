function onLoad()
    -- Create context Menus
    addContextMenuItem("Spawn Card", createUI)

    spawnObject({
        type = "Notecard",
        position = {0,1,0},
        callback_function = function(spawned_object)
            spawned_object.setName("Release Notes")
            spawned_object.setDescription(
[[Lots of changes in the latest update!
- New scenario toolbar
- Custom hotkeys (including new context-sensitive discard)
- Deck import will now look for both private and public decks
- Updated rulebook to version 1.7
- Various bug fixes and improvements

Check out the mod's page for more info!]]
            )
        end})

    addHotkey("Begin villain phase (add threat)", function(playerColor, object, pointerPosition, isKeyUp)
        local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
        if(not scenarioManager) then return end

        scenarioManager.call("threatButtonClicked")
    end, false)

    addHotkey("Deal encounter cards", function(playerColor, object, pointerPosition, isKeyUp)
        local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
        if(not scenarioManager) then return end

        scenarioManager.call("encounterCardsButtonClicked")
    end, false)

    addHotkey("Context-sensitive discard", function(playerColor, object, pointerPosition, isKeyUp)
        discardCardOrDeck({object = object, playerColor = playerColor})
    end, false)
end

function onObjectNumberTyped(object, playerColor, number)
    if (object.type ~= "Deck" and object.type ~= "Card") then
        return false
    end

    local nearbyObjects = findInRadiusBy(object.getPosition(), 4)
    local playmat = nil

    for _, obj in ipairs(nearbyObjects) do
        if obj.hasTag("playmat") then
            playmat = obj
            break
        end
    end

    if(object.type == "Card") then
        local cardData = getCardData({card = object})
        if(not cardData) then return false end
        if(cardData.aspect == "encounter" or cardData.type == "hero") then return true end

        removeCountersFromCard({card = object})

        if(not playmat) then
            local cardPlayerColor = getCardPlayerColor({card = object})
            object.deal(1, cardPlayerColor)
            return true
        end
    end

    if (playmat) then
        playmat.call("drawCards", {
            objectToDrawFrom = object,
            numberToDraw = number
        })
        
        return true
    end

    return false
end

function onObjectEnterZone(zone, card)

    local zoneDef = getZoneDefinition({zone = zone})
    if (not zoneDef) then
        return
    end
    if (not isCard(card)) then return end
    if(isFaceDown({object = card})) then return end

    local cardData = getCardData({
        card = card
    })

    local cardType = cardData.type

    if (cardType == "hero") then return end

    local playerColor = zoneDef.playerColor
    if (playerColor) then
        local currentPlayerColor = getCardValue({
            cardGuid = card.getGUID(),
            property = "playerColor"
        })

        if(not currentPlayerColor) then
            setCardValue({cardGuid = card.getGUID(), property = "playerColor", value = playerColor})
        end
    end

    if(zoneDef.rescaleOnEnterTo) then
        resizeCardOnEnterZone(card, zoneDef.rescaleOnEnterTo)
    end

    if(zoneDef.repositionCards) then
        positionCardOnEnterZone(card, zoneDef.zoneIndex)
    end

    if(zoneDef.addCountersAndTokens) then
        addCountersAndTokensToCard({card = card, cardData = cardData, zoneGuid = zone.getGUID()})
    end

    local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)

    if (zoneDef.onEnterFunction) then
        scenarioManager.call(zoneDef.onEnterFunction, {
            zone = zone,
            item = card
        })
        return
    end

    scenarioManager.call("onCardEnterZone", {
        zone = zone,
        card = card
    })
end

function resizeCardOnEnterZone(card, scale)
    if (card.isDestroyed()) then return end
    if( not scale ) then return end
    if(card.hasTag("do-not-resize")) then return end

    card.setScale(scale)
end

function positionCardOnEnterZone(card, zoneIndex)
    local cardType = getCardProperty({
        card = card,
        property = "type"
    })
    local newCardPosition = getNewZoneCardPosition({
        zoneIndex = zoneIndex
    })
    local originalRotation = card.getRotation()
    local cardRotation = string.sub(cardType, -6, -1) == "scheme" and {0, 90, originalRotation[3]} or
                             {0, 180, originalRotation[3]}

    card.setPositionSmooth(newCardPosition)
    card.setRotationSmooth(cardRotation)
    card.setScale(ENCOUNTER_DECK_SCALE)
end

function onObjectLeaveZone(zone, card)
    if (not card or card.isDestroyed() or not zone or zone.IsDestroyed()) then return end
    if (not isCard(card)) then return end

    local zoneDef = getZoneDefinition({zone = zone})
    if (not zoneDef) then return end

    local cardData = getCardData({card = card})
    if(not cardData) then return end

    local cardType = cardData.type or ""
    if (cardType == "hero") then return end

    if(zoneDef.addCountersAndTokens) then
        removeCountersFromCard({ card = card })
    end

    if(zoneDef.rescaleOnExit) then
        resizeCardOnLeaveZone(card, cardData.type or "")
    end

    if(zoneDef.repositionCards) then
        repositionCardsInZone({
            zone = zone
        })
    end

    if (zoneDef.onLeaveFunction) then
        local scenarioManager = getObjectFromGUID(GUID_SCENARIO_MANAGER)
        scenarioManager.call(zoneDef.onLeaveFunction, {
            zone = zone,
            item = card
        })
        return
    end
end

function resizeCardOnLeaveZone(card, cardType)
    if (card.isDestroyed()) then return end

    local zones = card.getZones()

    for _, zone in ipairs(zones) do
        local zoneDef = getZoneDefinition({zone = zone})
        if (zoneDef and zoneDef.rescaleOnEnterTo) then
            return
        end
    end

    local cardScale = getCardScaleByType(cardType)
    card.setScale(cardScale)
end

function getCardScaleByType(cardType)
    local cardScalesByType = {
        villain = CARD_SCALE_VILLAIN,
        attachment = CARD_SCALE_ENCOUNTER,
        environment = CARD_SCALE_ENCOUNTER,
        main_scheme = CARD_SCALE_MAIN_SCHEME,
        minion = CARD_SCALE_ENCOUNTER,
        obligation = CARD_SCALE_ENCOUNTER,
        side_scheme = CARD_SCALE_ENCOUNTER,

        hero = CARD_SCALE_IDENTITY,
        ally = CARD_SCALE_PLAYER,
        event = CARD_SCALE_PLAYER,
        player_side_scheme = CARD_SCALE_PLAYER,
        resource = CARD_SCALE_PLAYER,
        support = CARD_SCALE_PLAYER,
        treachery = CARD_SCALE_ENCOUNTER,
        upgrade = CARD_SCALE_PLAYER
    }

    return cardScalesByType[cardType] or CARD_SCALE_PLAYER
end

function onPlayerAction(player, action, targets)
    if (action == Player.Action.Delete) then
        for _, target in ipairs(targets) do
            if not target.getVar("preventDeletion") then
                target.destroy()
            end
        end

        return false
    end

    if (action == Player.Action.PickUp) then
        if (#targets > 1) then
            return true
        end
        local card = targets[1]

        if (not isCard(card)) then
            return true
        end

        if (not isFaceUp({
            object = card
        })) then
            return true
        end

        local zones = card.getZones()
        if #zones > 0 then
            return true
        end

        local cardType = getCardProperty({
            card = card,
            property = "type"
        }) or ""
        local zoneType = nil

        if (string.sub(cardType, -11) == "side_scheme") then
            zoneType = "sideScheme"
        elseif (cardType == "attachment") then
            zoneType = "attachment"
        elseif (cardType == "environment") then
            zoneType = "environment"
        elseif (cardType == "minion") then
            zoneType = "minion"
        end

        if (not zoneType) then return true end

        local zoneDefs = getZoneDefinitionsByType({
            zoneType = zoneType
        })

        for _, zoneDef in ipairs(zoneDefs) do
            local pingPosition = getNewZoneCardPosition({
                zoneIndex = zoneDef.zoneIndex,
                forNextCard = true
            })

            if (pingPosition) then
                player.pingTable(pingPosition)
            end
        end
    end

    return true
end

function onObjectDestroy(object)
    if (not isCard(object)) then return end
    
    local cardGuid = object.getGUID()

    local keepInRegistry = getCardValue({
        cardGuid = cardGuid,
        property = "keepInRegistry"
    })

    if(keepInRegistry) then
        setCardValue({cardGuid = cardGuid, property = "standardCounterGuid", value = nil})
        setCardValue({cardGuid = cardGuid, property = "standardRetainedValue", value = nil})
        setCardValue({cardGuid = cardGuid, property = "configuredCounterGuid", value = nil})
        setCardValue({cardGuid = cardGuid, property = "configuredRetainedValue", value = nil})
    else
        deleteCardFromRegistry({cardGuid = cardGuid})
    end
end

-- function onObjectSpawn(object)
--     if (not isCard(object)) then return end
    
--     -- Ensure newly spawned/created cards (including from decks) can be picked up
--     object.use_hands = true
-- end

function onObjectRotate(object, spin, flip, player_color, old_spin, old_flip)
    if (not isCard(object)) then return end
    if (spin == old_spin) then return end

    rotateCountersWithCard({card = object, spin = spin, oldSpin = old_spin})
end